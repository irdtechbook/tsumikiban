# 積み基板を回避するために

前の章で、様々な心理的ハードルやモチベーションに関わる面での障害について述べました。モチベーションを保つのがいかに難しいか、といった内容を取り上げました。本章では、それらの対策となりうる様々な項目を取り上げます。

* 目的を決める
    * 「基板を使う」も目的の一つ
    * 作りたいものを作る
* 作ってみる
    * 手を動かす
    * みんなでやる
    * 一人で作る
* 新しいものを作る
    * 今困っていることを探す
    * 要件定義とMVP
    * 飽きたらやめる
    * 今あるものを作ってみる
* 進捗のニンジンを作る
    * 小さい目標を立て自分をほめる
    * 成果をアウトプットする
* ソースコード管理など、ソフト開発の手法を取り入れる

## 目的を決める

工作する目的は何でしょう？基板を使う（使ってみる）ということ自体も目的になります。基本的には、基板を使うこと自体は手段であり、目的はあくまで課題解決であるという認識を持つ方がスムーズに目的を達することができるでしょう。

### 「基板を使う」ことを目的にする
基板を使うこと自体を目的にすると、いろいろな機能を使ってみたくなります。またその基板自体について調べたり、特徴について深く理解することができるでしょう。新しいデバイスを見かけて、今までのとはここが違うから買ってみた、という経験はたいていの人にあるのではないでしょうか。Wi-Fiが内蔵された、高速通信ができるようになった、無線伝達距離が長い、低消費電力らしい、IOが多い、CPUの性能が高い、小型、etc…

それらの特長を目いっぱい楽しみましょう。その特長を生かすためのわかりやすい機能を盛り込んだ何かを作る、探すことで理解も深まります。また、ここで作った経験は、次に何かを作るときの選択肢にかかわってくるでしょう。

例えば、低消費電力がウリなボードで遊んだ経験があったとして、しばらく経って屋外に置くタイプのデバイスを作ることになったとしましょう。この時、過去の経験が活きてきます。低消費電力であることも知っているし、いくつかの機能、使用感も知っている、となれば採用の可能性は高まります。少なくとも使ったこともないデバイスの中から選ぶといったことはありません。

### デバイスは手段である

とはいえ、どういったデバイスを使うか、という選定はあくまで手段の選定です。たいていの場合は特定のデバイスでないと実現できないというシチュエーションは起こりません。部品が少し増えたり、分解能がどうかといった点で少し物足りないものになる可能性がありますが、プロトタイプとしてさっくりとくみ上げてしまいましょう。そのうえで、改善のイテレーションを回せばよいのです

ソフトウエア開発でも類似の状況になることは多いでしょう。特定の言語（例えばアセンブラ）でカリカリにチューニングして書かなければいけないようなシチュエーションも世の中にはありますが、たいていの場合は、言語そのものの選定より、アルゴリズムの選定が重要な場合が多いといったことを想定してください。もちろんクリティカルなミッションである場合もあるでしょう。ですが、特定部分以外は形になっている状態を作り上げることで、システム全体として問題ないのか、改善すべきところはどこか、といった観点で再設計、改善仕様提案が可能となります。手元にあるデバイスで一度作ってみましょう。必要十分かもしれません。足りないところがあればそこについて対応を取りましょう。

## まずは何か作ってみる
まずは作ってみないことにはやる気もわいてきません。積み基板上等。手を動かしてみましょう。作ってみてわかることもたくさんあります。

### 手を動かし始めよう
まずは手を動かしてみます。この時、できるだけ機能の少ないものにするのがコツです。さくっと作れる単機能なものであれば、飽きる前に終わらせることもできるでしょう。単機能なものをいろいろ作って、個別機能に関する知識をためていけば、将来大きなものを作る時にその単機能を組み合わせて作り上げることができます。

作り終わったら、堂々と積み基板にしてしまいましょう。買ったけど使わなかった、何となくLチカだけやって積んでいる「積み基板」と、ここで行ったシンプルな何かを作って用が済んだ「積み基板」は別ものです。

単機能の実装経験は、アプリのモジュールのように使いたいときに使える武器です。定番のもので構わないので引き出しは増やしておくとよいです。多少特性が変わったりしても、素子やコードを少し変えれば使いまわしができるようになってきます。

また、こういった使ったことのあるモジュールが増えてくると、自然に周辺の部品なども増えてきます。引き出しを探せば必要なものが出てくる、という状況に自然となっていくでしょう。部品沼への入り口ですが。さて、細かい部品などは実装したまま置いておくとすぐ使うことができます。抵抗やコンデンサなどの細かい部品がなくて困るといったことも防げます。保管スペースとのトレードオフになりますから無尽蔵にとは言えませんが、次に使いそうなものだけでも残しておくとよいかもしれません。

### みんなでやる
何もチーム開発をやろうという意図ではありません。チーム開発もよいのですが、ここではもくもく会のような空間で、みんなで作業しましょう、というニュアンスです。一人でやっていれば集中がそがれてついTwitterを見てしまったりしますが、周囲でみんなが集中していると自然と集中できますよね。

昨今の状況ではみんなで集まってというのは難しい面もありますが、オンラインで繋いで作業する、といったこともやりやすくなっています。

定期的にアウトプットすることで作業の一体感を作り出すこともできます。なんなら、自分でClubhouseやZoomなどの場所を作ってやってみるというのも良いですね。Zoomは3人以上だと時間制限があるなど、無料ならではの制限もありますが、とりあえずは無料枠でやってみて、進捗が出るようなら進捗を得るための投資だと考えて課金してみるのも一興です。他でも使えますしね。

開催を継続していればもくもく会自体がコミュニティになっていきます。そこから生まれるプロジェクトや企画もあります。アドバイスをもらったり他の人にフィードバックしたり、よいループが回り始めます。そういったコミュニティや空間を主催するのもアウトプットの一つの形です。

### 一人で作る
一人で作る場合も、ぜひ「こんなものを作り始めた」といったこと、あるいは「ここに困った」などをTwitterなどでつぶやいてみましょう。応援のいいねが付いたり、困ったことへのアドバイスが来るかもしれません。また進捗をアウトプットすること自体が進捗のモチベーションになります。やったことのふりかえりや次にやることの整理などが自然とできるでしょう。

アウトプットすることで、自然に今日やったこと、次にやることのふりかえりができます。

## 新しいものを作る
何か新しいものを作るという行為自体が大きなモチベーションになります。

今作ってるものに飽きたら、一度そちらは中断して、新しいものを作ってみるのもアリです。頭の片隅においておいて、思い出した時が戻るとき。個人開発なので、気が向いたらでOKです。

では、「新しいものを作ろう」と思ったときどうすればよいでしょうか？

### 今困っていることを探す
今困っていることを探してみましょう。ちょっとしたことで構いません。そして「その困ったことを解決するためのツールを作る」という目標を立てて、何かを作ってみましょう。それはハードウエアかもしれません。ソフトウエアかもしれません。ハードとソフトを組み合わせることで解決することができるかもしれません。

自身が直面している「困ったこと」を解決するということは、非常に明確かつ強いモチベーションになります。そして、自分が欲しい機能が明確になりますので、不要な機能を「あると便利かも？」といったあいまいなニーズに基づき追加しようとしてプロジェクトが肥大化するといったことが起こりません。

### 要件定義とMVP
ソフトウエア開発、特にアジャイル開発の文脈で、MVPという言葉が頻繁に出てきます。

Minimum Viable Productの略で、実用最小限の製品と訳されます。最小限の機能をもつ製品で、「動作する」ことが重要です。したがって、見た目だけの「モックアップ」とは異なります。様々な機能や見た目の改善などいくつものポイントの中で、目的に対して必要な最低限の機能だけを有するものです。

MVPを作る目的は、小規模な製品を作り、テストし、フィードバックを行うというループをできるだけ小規模かつ迅速に回すことにあります。すべてが完成した時にテストをするようでは、テスト項目が莫大になります。実際にできあがったものが実は自分のニーズとずれているかもしれません。最後に動くまでどんなものができあがるかわからない状態では開発のモチベーションも失われやすくなります。

最初から大きなものを作ろうとして、挫折する、何から手を付けてよいかわからない、などは開発あるあるでしょう。

MVPは、「動くもの」と言い換えてもいいかもしれません。動くというものを作り上げるということは簡単なようで結構難しいもの。小さく、だけど動くところまで仕上げることで、アジャイル開発でいうイテレーションのような小さな開発サイクルを繰り返し、問題の発見や改善を進めていくことができます。

### 区切りの良いところまでは頑張る
そうはいっても、区切りの良いところまでは頑張りましょう。飽きたらやめてよい、というのと矛盾するようですが、明確に見えているマイルストーンがあるなら、そこを目標とするのはとても良い選択です。

飽きてきたときでも、次の区切りが見えているならそこまで頑張れると思いませんか？

### 飽きたらスパっとやめる
飽きたら、スパっとやめるというのも一つの選択です。

30分調べてみてわからなかったら別の方法を試す、30分いろいろやってみて解決できないときは一回ばらしてみる、他の部分に着手するなど、気持ちを切り替えましょう。ハマっているときは、ずるずる時間ばかり経過して、かつ少ない進捗にイライラすることもあるでしょう。無理してもあまりよいことはありません。プロジェクト自体が嫌になってしまっては元も子もありません。

きっといつか戻ってくる日が来るでしょう。あるいは、戻ってこなかったときは、それは作る必要のなかった作品かもしれません。

### 今あるものを作る

「何を作るか」に迷ったときの一つの解決策です。「今あるもの」を作ってみましょう。時計、タイマー、あるいは温度計などがいいかもしれません。すでにあるものですが、これらを自分で作ってみましょう。

メリットはいくつかありますが、以下のようなメリットが考えられます。

* 機能・仕様が明確でお手本がある
* 作例も多い
* 機能のストックができる

既存のものを作る場合、必要な機能で迷うことがなくなります。必要な機能や仕様がゴールとして見えているので、そこに至る道を一歩一歩たどっていきましょう。そして、作例や情報も一般的には多く見つかるでしょう。困ったらそういったものを参考にすることができます。

さらに、同じものを作るとはいえ、実装や部品選定はあなた次第ですから、あなたのオリジナルのものができます。そして、実際にその部品を使った、機能や実装を試したという意味で、血肉となり、次回のもっと大きい、あるいは複雑な何かを作るときの参考とすることができるでしょう。

また、既存のものに機能を追加するときも、その部分だけを追加すればよいので、何をやるかは明確です。温度計を考えると、温度を測定し、表示するという「当たり前」の機能の部分をまず作ります。次に何をしようかな？と考えて、「データを保存する」機能を追加するとしましょう。この時、記録するためのストレージ（例えばSDカード）への読み書きの機能を追加すればよいとわかります。あるいは、1時間おきに記録したデータをLINEやSlackなどに飛ばすことを考えてみましょう。ネットワークに接続する、LINEなどのAPIを使う、といった形で明確化することができます。

今あるものをまず作ってみて、さらにそこにちょい足しで何かを作る、というアプローチを取ることで、大きなジャンプなく作り上げることができるでしょう。またこの過程では、多少の得手不得手や費用の差はあるとしても、たいていのデバイスで実現することができます。一つのデバイスで作ってみたものを他のデバイスに移植するということも、経験・機能のストックとして大変有用です。そして、ネットワーク機能を内蔵している、ストレージに余裕がある、処理能力が高い、入出力の数が多い、安価である、消費電力が小さいなど、デバイス間の差や用途・得意不得意が見えてきます。こういった一つ一つの経験、実体験により、次に作るものはより洗練され、かつ最短距離で実装を完了させるための近道となります。

### 他の環境に移行してみる
一つ作り上げたものがあったとき、それを別の環境に移行して、同じ物を作ってみる、という開発ネタの見つけ方があります。

例えばArduinoをメインボードとして使ったデバイスがあったとします。これをRaspberryPiに変えてみるのです。デバイスごとに入出力の扱い方が異なります。できることも異なります。入出力チャンネル数にも差があります。ない機能を実装するために外付けデバイスを使う必要があるかもしれません。その過程でいろいろな学びがあることでしょう。ゴールが明確な分、ピンポイントに調べることもできますし、参考になる情報を手に入れやすくなるでしょう。また、類似機能についての横断的な知識を得ることにもなるなど、たくさんのメリットがあります。

同じことは、内蔵機能から、外付けデバイスに変更してみるという形でも実現できます。例えば10bitの内蔵ADCを使ってデータを取り込んでいたところを、外付けの16bitのADCに改造してみるのです。性能は向上しますし、新しいADCを使った経験を得るというメリット、実績を積むことができます。適切なライブラリを探してくるところ、通信関係、処理速度やデータの保存などの部分で知識・経験を増やすことができました。おめでとうございます。

## 進捗のニンジンを作る
進捗というニンジンを鼻先にぶら下げることはモチベーションの上で大きな効果があります。そのニンジンのぶら下げ方を二つ挙げます。

### 小さな目標を立て自分をほめる
最終目標はあるでしょうが、「小さな目標」にブレイクダウンし、それを達成して、気持ちよくなりましょう。自分をほめてあげることが重要です。自己肯定感上げていきましょう。

小さい目標にブレイクダウンすることで様々なメリットが生まれます。小さい目標は、タスクと言いかえることができます。

* 実装の要件がはっきりする
* 次に何をやるかが明確になる
* ふりかえりがやりやすい
* 今日（今回作業）の進捗が見えやすい

小さな目標が達成、完了したということは、当たり前ですが「完了した」ということを認識します。結果、今回のタスクがどうだったのか、予定通りだったのか予想外の困ったことがあったのか、所要時間はどうだったか、何を得たか、次に何をするか、などさまざまな項目について自然とふりかえりが行われます。

目標サイズは任意で決めて構いませんが、最大でも1日の作業のサイズとしましょう。あるいは2時間程度の作業量が適当かもしれません。趣味開発ですから本業の傍ら、例えば夜や休日の昼間にやる内容でしょうから、集中して2時間程度というのが根拠になります。2時間だと大したことがでいない？という向きもあるかもしれませんが、ポモドーロテクニック[^pomodoro]を使うと、(25分+5分)×4の作業量になりますから、集中すればかなりの作業量になります。また、予想外に時間がかかってしまったとしても、それだって立派なふりかえりです。次に持ち越しましょう。

[^pomodoro]: ポモドーロテクニック：25分の作業と5分程度の短い休憩で分割し、この1セットを1ポモドーロとし、4ポモドーロで長めの休憩を取るという手順で行う時間管理術。また、一つのタスクを1ポモドーロで完結するように設定する、割り込みがあったら中断し新たに1ポモドーロを設定する、などありますが、集中して進捗を出すことができるテクニックです。

目標が大きすぎると、あるいは最終的に完了したときのみふりかえりを行うような状況を考えてみてください。全体的に苦労したけど楽しかった、といったもやっとした感想になってしまいませんか？楽しいことはよいことですが、前述のような粒度の細かいふりかえりは難しいと考えざるをえません。

### 成果をアウトプットする
アウトプットの効能については別章を立てました。詳細はそちらを参照ください。

アウトプットすること自体がモチベーションになりますし、知識や成果の体系化にも非常に大きな効果があります。

アウトプットすることで、進捗が見えやすくなります。可視化されます。

## 締切を作る
何か明確な締切があると、大幅に進捗します。

個人開発は一般に明確な締切がないことが多く、また前述の課題解決型の目標・ゴール設定であっても「ないならないなりに何とかなる」という状況になりがちです。その結果として、ずるずる遅れ、モチベーションがどんどんなくなり、はじめてはみたものの・・・やりかけ箱の中でホコリをかぶるという状況になります。

この時、明確な締切を作ることができれば、所要時間と進捗をきちんと定義することができます。特に開発ステップを細かいタスクに分割することができればもう勝利は目前です。

締切は全体締切と機能・ステップごとの締切を別々、あるいは階層化して設定することで、タスクとしての明確化、マイルストーンとしての設定もできます。マイルストーンが明確になれば、あとは目の前のタスクをこなすだけ。遠大なゴールにめまいがすることもなくなります。

また、締切があることで、締切直前の追い込み進捗にも期待できます。1行前にマイルストーンを明確にすると進捗が出る、などと述べたばかりで舌の根も乾かぬうちに、ではありますが…

### コンテスト・イベントに応募する
締切を作るという方法に類似しますが、より強制力のある締切を設定する方法でもあります。

コンテストやイベントは、開催日やエントリー期限などの「外的な」締切が設定されます。しかも、大抵はエントリー期限と提出期限、あるいは本番（イベント日）というふうに、締め切りが多段に設定されます。エントリーの段階では多少見切りで発進・エントリーしてしまっても、本番や提出日といった最終期限までに何とかするという強いモチベーションになります。モチベーションこそが進捗の源泉です。

また、最終目標までは到達しなくても、最低限の動きを実装したりまではできることがあるでしょう。これはちょっと見方を変えると、MVPといえるかもしれません。

そしてイベントなどでフィードバックを貰い、明日からの進捗の糧としましょう。イベントに出ると、様々な人がほめてくれます。質問もたくさん来るでしょう。実装のヒント、改善のヒントがもらえるかもしれません。またコミュニティ、界隈との繋がりのきっかけになることもあるでしょう。

## ソフト開発の手法を取り入れる
ソフトウエア開発の分野では、アジャイル開発といわれる開発手法が近年メジャーになっています。ここまで述べたいくつかのトピックスは、アジャイル開発の中で言われる内容を取り入れたものです。アジャイル開発自体非常に幅広くかつ深遠なテーマですから、すべてを書きることはできません。筆者の知っている範囲は非常に狭いので、そういう手法を取り入れるといいですよ、という小さなフックを作るにすぎません。ですが、これまで何回か挫折した方、積み基板を作ってきた方は、電子工作の入門書を新しく買うのではなく、アジャイル開発に関する書籍を一度読んでみるなどしてみてはどうでしょう？一部取り入れるだけでも大幅に進捗が出るかもしれません。

### ソースコード管理をする
ソースコード管理はGit等でやりましょう。ArduinoIDEをはじめとした標準の開発環境だけを使って開発する人もいるかもしれませんが、どこを変更したのか、といったコメント付きで管理できる、必要に応じて元に戻せるという状況は非常に有用です。ローカルにあるソースコードを管理するだけで実現します。

Gitクライアントを使って更新ごとに何をやったかといった情報を記録するだけでも十分です。ハマったときにいろいろやったけどどれが決定打だったのかといったことは、できあがったソースだけを見てもわからないことがあります。それに対し、Git等を使うと差分込みで可視化することができます。

ソースコードは基本的にはテキストです。プロジェクトのあるフォルダをそのまま指定するなどでもたいていの場合は問題ないでしょう。中間ファイルなどがうっとうしい場合は、.gitignoreを適当に設定するなども必要でしょう。大抵の場合、コンパイルされた実行ファイル、中間ファイルなどは保存する必要はありません。

トライアンドエラーになりがちな電子工作ですが、物理面もバージョン管理ができたらいいのに・・・とは思いつつ、まずはソフト・コードだけでも管理できるようになるとよいですね。普段からGitを使っている人はそのまま使ってみましょう。初めての人は、「わかばちゃんと学ぶGit使い方入門」[^wakabagit]などを読みながらやってみてください。手戻りが怖くなくなるなど、とっても有益です。

[^wakabagit]: 改訂2版 わかばちゃんと学ぶ Git使い方入門 https://www.amazon.co.jp/gp/product/B096TH798S/

### 要件定義・MVP
これは先に述べましたので、ここで再度触れることはしません。要件定義そのものはアジャイル特有のものではありません。ましてソフト開発にしかないものではありません。しかし、要件定義の行うにあたってのテクニックなど、参考にするとよい考え方はたくさんあります。ハードウエアしかやったことがありません、という方も、けっきょく何かを作り上げるにはコードを書く必要はあります。むしろ過去の電子工作に比べると、マイコン、そしてそこに書き込むソフトウエアの重要性、比率は上がってきています。

例えば、「電子工作」というイメージでラジオを作る場合、従来は各素子の特性を検討し、部品を集めてきて、はんだ付けをするという手順で、ソフトウエアの介在する余地はありませんでした。しかし現在の”電子工作”において、Ｌチカするにもコードを書く必要があるのはご存じのとおりです。現在の電子工作におけるソフトウエア、コーディングの占める割合は非常に大きくなっています。

### アクティブな素子・パッシブな素子

従来の電子工作において、R（抵抗）,L（リアクタンス：コイル）,C（キャパシタンス：コンデンサ）などの素子をパッシブ素子、オペアンプなどをアクティブ素子と呼ぶことがありました。オペアンプは電源を供給して、入力信号を増幅したりすることができますから、確かにアクティブ素子です。しかし、先に述べたように、コードによって能動的に動くかという意味では、特に命令しなくても（物理的に増幅率や挙動を定めているとはいえ）、能動的に動いているというイメージは持ちづらいでしょう。

これに対し、センサ信号をとってきて、それを処理し、表示するといった形での電子工作では、「能動的」に動いている部分がわかりやすい、あるいは増えていると考えることもできます。

世の中的にアクティブ素子という概念が変わってくるというところまできてはいませんし、まだアクティブ素子、パッシブ素子といった表現は変化しないでしょう。とはいえ、そういった意味で、従来の電子工作にあるようなパッシブなイメージはいったん脇に置いておいて、自分が書いたコードによっていろいろなデバイスが動く、というふうに考えると良いかもしれません。

そして、マイコンによって積極的に入出力を行い、その前処理・後処理を回路で行うと考えると、全体のイメージがつきやすくなります。また、「適切な」レベルに変換する前に、とりあえず生信号を取り込んでみて実装してみるというふうにステップを分けることもできます。

生信号の大きさが少々小さくても、まずは直接取り込んでみるという選択肢が取れます。増幅部分の実装という「手間」を省き、かつ部品点数を減らせますので、不具合が生じる可能性が少し下がります。まずはデータが取り込めることを核にしたのち、増幅を実装します。とはいえ、これはいつでもできるというわけではなく、生信号が大きすぎる場合などは、取り込みデバイスを壊す可能性があるので、注意は必要です。その場合は逆に分圧回路を先に組み立て、オシロやテスタで「適切な信号が来ているか」をまず確認する、といった手順でも構いません。



## まとめ
前の章で述べた「個人開発を阻害する要因」「積み基板を生み出す要因」に対し、いくつかの解決策となる可能性のあるテクニックをご紹介しました。

根底に共通するのは、目標と進捗を可視化しよう、という点に尽きるのかもしれません。
